#include<iostream>
#include<string>
#include<iomanip>

#include "Z_80LogicGate.h"
#include "WaveformFSM.h"

#define Z_80_BUS_WIDTH 				8
#define Z_80_ADDRESS_WIDTH 			16

#define TIME_DEVISOR                100

#define CONTINUOUS_LABEL "Executing.  Press the T-step or I-step button to execute at t-state or instruction level stepping"

using namespace std;


#ifndef _PRODUCTION_
extern ofstream* logiclog;
#endif

//These functions take strings and
//make them paramiter transportable.
//(i.e. they remove all the spaces
//and encode them as something else)
string encodeParam(string param) {
	ostringstream la;
	if (param.length() > 0) {
		for (unsigned int i = 0; i < param.length(); ++i) {
			if ((param[i] >= '0' && param[i] <= '9') ||
				(param[i] >= 'a' && param[i] <= 'z') ||
				(param[i] >= 'A' && param[i] <= 'Z')) {
				la << param[i];
			}
			else {
				la << '\\' << uppercase << hex << setfill('0') << setw(2) << ((int)param[i]);
			}
		}
	}
	else {
		la << "\\BLANK";
	}
	return la.str();
}
string decodeParam(string param) {
	ostringstream ostream;
	if (param != "\\BLANK") {
		for (unsigned int i = 0; i < param.length(); ++i) {
			if (param[i] != '\\') {
				ostream << param[i];
			}
			else {
				if (i + 2 < param.length()) {
					//the character is encoded as two hex
					//characters
					ostringstream hexNums;
					hexNums << param[i + 1] << param[i + 2];
					istringstream hexToInt(hexNums.str());
					int hexValue = 0;
					hexToInt >> hex >> hexValue;
					ostream << (char)hexValue;

					//now we update i because we need it to skip
					//the two hex digits that we used
					i += 2;
				}
			}
		}
	}
	else {
		//the string is intentionaly blank
	}
	return ostream.str();
}
string toHex(int num) {
	ostringstream hexer;
	hexer << hex << uppercase << num;
	return hexer.str();
}
string toDec(int num) {
	ostringstream stream;
	stream << num;
	return stream.str();
}


//---------------Z_80LogicGate-------------------------------
Z_80LogicGate::Z_80LogicGate() :
	Gate(),
	//runningProcessGate needs to be faulsified
	//before waveformFSM gets constructed.
	runningProcessGate(false),
	waveformFSM(this) {

	currentRunMode = CONTINUOUS;
	hasRecievedRise = false;
	powerWarning = false;
	setContinouseInfo = false;
	currentKeyboardHardCode = H_KEY_NONE;

	declareInput("CLK", true);


	declareInput("VCC");
	declareInput("GND");

	//declared inputs and outputs

	//descriptions from "1982/83 Data Book" by Zilog
	//ignor references to refreshing dynamic memory.
	//this functionality will not be implemented because
	//it will detract from the student's ability to 
	//understand the meaning of each fetch from memory

	//Address Bus(output, active High,
	//3-state).  A0-A15 form a 16-bit address bus.  The
	//Address Bus provides the address for memory
	//data bus exchanges(up to 64K bytes) and for
	//I/O device exchange
	declareOutputBus("A", Z_80_ADDRESS_WIDTH);

	//Bus Acknowledge (output, active
	//Low).  Bus Acknowledge indicates to the
	//requesting device that the CPU address bus,
	//data bus, and control signals /MREQ, /IORQ,
	// /RD, and /WR have entered their high-
	//impedance states.  The external circuitry
	//can now control these lines.
	declareOutput("/BUSACK");

	//Bus Request (input, active Low).
	//Bus Request has a higher priority then /NMI
	//and is always recognized at the end of the cur-
	//rent machine cycle. /BUSREQ forces the CPU
	//address bus, data bus, and control signals
	// /MREQ, /IORQ, /RD, and /WR to go to a high-
	//impedance state so that other devices can
	//control these lines. /BUSREQ is normally wire-
	//ORed and requires an external pullup for
	//these applications.  Extended /BUSREQ
	//perids due to extensive DMA operations can
	//prevent the CPU from properly refreshing the
	//dynamic RAMs.
	declareInput("/BUSREQ");

	//Data Bus (input/output, active High,
	//3-state D0-D7 constitue an 8-bit bidirectional
	//data bus, used for data exchanges with
	//memory and I/O
	declareInputBus("D_IN", Z_80_BUS_WIDTH);
	declareOutputBus("D_OUT", Z_80_BUS_WIDTH);

	//Halt State (output, active Low). /HALT
	//indicates that the CPU has executed a Halt
	//instruction and is awaiting either a non-
	//maskable or a maskable interrupt (with the
	//mask enabled) before operation can resume.
	//While halted, the CPU executes NOPs to
	//maintain memory refresh.
	declareOutput("/HALT");

	//Interrupt Request (input, active Low).
	//Interrupt Request is generated by I/O devices.
	//The CPU honors a request at the end of the current instruction if the internal software-
	//controlled interrupt enable flip-flof (IFF) is
	//endables. /INT is normally wire-ORed and
	//requiers an external pullup for these
	//applications.
	declareInput("/INT");

	//Input/Output Request (output, active
	//Low, 3-state). /IORQ indicates that the lower
	//half of the address bus holds a valid I/O
	//address for an I/O read or write operation.
	// /IORQ is also generated concurrently with /M1
	//during an intrrupt acknowledge cycle to indi-
	//cate that an interrupt response vector can be
	// placed on the data bus
	declareOutput("/IORQ");

	//Machine Cycle One (output, active Low).
	// /M1, together with /MREQ, indicates that the
	//current machine cycle is the opcode fetch
	//cycle of an instruction execution.  M1, together
	//with IORQ, indicates an interrupt acknowledge
	//cycle.
	declareOutput("/M1");

	//Memory Request (output, active
	//Low, 3-state). /MREQ indicates that the address
	//bus holds a valid address for a memory read or
	//memory write operation.
	declareOutput("/MREQ");

	//Non-Maskable Interrupt (input, active
	//Low, edge-triggered). /NMI has a higher pri-
	//ority then /INT. /NMI is always recognized at the end of the current instruction, independent of the status of the interrupt enable flip-flop, and automatically forces the CPU to restart at
	//location 0066H.
	declareInput("/NMI");

	//Read( output, active Low, 3-state). /RD in-
	//dicates that the CPU wants to read data from
	//memory or an I/O device.  The addressed I/O
	//device or memory should use this dignal to
	//gate data onto the CPU data bus.
	declareOutput("/RD");

	//Reset(input, active Low). /RESET
	//initializes the CPU as follows: it resets the
	//interrupt enable flip-flop, clears the PC and
	//Registers I and R, and sets the interupt status
	//to Mode 0.  During reset time, the address and
	//data bus go to a high-impedance state, and all
	//control output signals go to the inactive state.
	//Note that /RESET must be acive for a minimum
	//of three full clock cycles before the reset
	//operation is complete.
	declareInput("/RESET");

	//Refresh (output, active Low).  /RFSH,
	//together with /MREQ, indicates that the lower
	//seven bits of the system's address bus can be 
	//used as a refresh address to the system's
	//dynamic memories
	//Note: This functionality will not be implemented
	//declareOutput("/RFSH");

	//Wait (input, active Low). /WAIT
	//indicates to the CPU that the addressed mem-
	//ory or I/O devices are not ready for a data transfer.  
	//The CPU continues to enter a Wait
	//state as long as this signal is active.  Extended
	// /WAIT periods can prevent the CPU from
	//refreshing dynamic memory properly.
	declareInput("/WAIT");

	//Write (output, active Low, 3-state). /WR
	//indicates that the CPU data bus holds valid
	//data to be stored at the addressed memory or
	//I/O location.
	declareOutput("/WR");
}

//this filters out all the gateProcesses that we don't want
//it forwards on to the waveformFSM rising or
//falling edges of edges of clocks
void Z_80LogicGate::gateProcess() {
	//runningProcessGate lets safeListChangedParam know
	//when it is being called by a function that
	//was called by gateProcess or not.
	runningProcessGate = true;

	processSafeListedParams();


	bool isRising = isRisingEdge("CLK");

	if (isPowered()) {
		if (isRising) hasRecievedRise = true;

		//only bother the waveformFSM on a rising or falling
		//edge of the clock
		if (isRising || (isFallingEdge("CLK") && hasRecievedRise)) {

			//tell the user if we are running continuously
			if (currentRunMode == CONTINUOUS) {
				if (!setContinouseInfo) {
					setInfoString(CONTINUOUS_LABEL);
					setContinouseInfo = true;
				}
			}
			else {
				setContinouseInfo = false;
			}

			//now process this T-state
			waveformFSM.nextState(this, isRising);
		}

		//non maskible interupts are asyncronouse
		//thus the waveformFSM needs to be told when they happen
		if (isFallingEdge("/NMI")) {
			waveformFSM.notifyOfNMI();
		}
		if (powerWarning) {
			setInfoString(infoStringBackup);
			powerWarning = false;
		}

	}
	else {
		//warn user that they forgot to power and ground the z80
		if (!powerWarning) {
			infoStringBackup = infoString;
			setInfoString("Warning: Make sure your Z-80 is powered and grounded");
			powerWarning = true;
		}
	}

	//we can't get the sim time from within the set property
	//location, so we set this flag so that we will do it out here.
	if (needToTimeStampKeyStroke) {
		keyboardHardCodeSetTime = this->getSimTime();
		needToTimeStampKeyStroke = false;
	}

	runningProcessGate = false;
}

//these methods are used by WaveformFSM
//to set the gates inputs and outputs
void Z_80LogicGate::setAddressBus(AddressType address) {
	setOutputBusState("A", ulong_to_bus(address, Z_80_ADDRESS_WIDTH), CLK_R_TO_ADDRESS_6 / TIME_DEVISOR);
}

void Z_80LogicGate::floatAddressBus() {
	vector< StateType > allHI_Z(Z_80_ADDRESS_WIDTH, HI_Z);
	setOutputBusState("A", allHI_Z, CLK_R_TO_ADDRESS_FLOAT_44 / TIME_DEVISOR);
}

void Z_80LogicGate::setBUSACKActive(bool isActive, TimeType delay) {
	setOutputState("/BUSACK", getLowActiveState(isActive), delay / TIME_DEVISOR);
}


void Z_80LogicGate::setDataBus(DatabusType data, TimeType delay) {
	//	vector< StateType > ulong_to_bus( unsigned long number, unsigned long numBits );

	setOutputBusState("D_OUT", ulong_to_bus(data, Z_80_BUS_WIDTH), delay / TIME_DEVISOR);
}

void Z_80LogicGate::floatDataBus() {
	vector< StateType > allHI_Z(Z_80_BUS_WIDTH, HI_Z);
	setOutputBusState("D_OUT", allHI_Z, CLK_R_TO_DATA_FLOAT_42 / TIME_DEVISOR);
}

void Z_80LogicGate::setHALTActive(bool isActive, TimeType delay) {
	setOutputState("/HALT", getLowActiveState(isActive), delay / TIME_DEVISOR);
}

void Z_80LogicGate::setIORQActive(bool isActive, TimeType delay) {
	setOutputState("/IORQ", getLowActiveState(isActive), delay / TIME_DEVISOR);
}

void Z_80LogicGate::setMREQActive(bool isActive, TimeType delay) {
	setOutputState("/MREQ", getLowActiveState(isActive), delay / TIME_DEVISOR);
}

void Z_80LogicGate::setM1Active(bool isActive, TimeType delay) {
	setOutputState("/M1", getLowActiveState(isActive), delay / TIME_DEVISOR);
}

void Z_80LogicGate::setRDActive(bool isActive, TimeType delay) {
	setOutputState("/RD", getLowActiveState(isActive), delay / TIME_DEVISOR);
}

void Z_80LogicGate::setWRActive(bool isActive, TimeType delay) {
	setOutputState("/WR", getLowActiveState(isActive), delay / TIME_DEVISOR);
}



//these methods are used by WavefromFSM
//to get the data on the inputs and outputs
bool Z_80LogicGate::isWAITActive() {
	return isLowActiveState(getInputState("/WAIT"));
}
bool Z_80LogicGate::isINTActive() {
	return isLowActiveState(getInputState("/INT"));
}
bool Z_80LogicGate::isRESETActive() {
	return isLowActiveState(getInputState("/RESET"));
}
DatabusType Z_80LogicGate::readDataBus() {
	return (int)bus_to_ulong(getInputBusState("D_IN"));
}

//a handy method for turning a bool into a ONE
//or ZERO
StateType Z_80LogicGate::getLowActiveState(bool isActive) {
	if (isActive) {
		return ZERO;
	}
	else {
		return ONE;
	}
}

//a handy method for returning true if a mentioned
//method is active
// this and the next method were returning StateType, but they are clearly returning a bool type
// so modified this the spec and here to conform   KAS
bool Z_80LogicGate::isLowActiveState(StateType state) {
	if (state == ZERO) {
		return true;
	}
	else {
		return false;
	}
}

//a handy method for returning true if a mentioned
//method is active
bool Z_80LogicGate::isHighActiveState(StateType state) {
	if (state == ONE) {
		return true;
	}
	else {
		return false;
	}
}

//this method is called by the waveformFSM or InstructionManager
//when they need to cause the simulation to stop because
//they have hit their breakpoints
void Z_80LogicGate::breakSimulation() {
	//the way that we cause the simulation to pause
	//is by signaling that "PAUSE_SIM" has changed
	safeListChangedParam("PAUSE_SIM");
}

//this method is called by Z_80Registers when a register changes
//this is so that the GUI is noteified of the current content
//of the registers.
void Z_80LogicGate::notifyOfRegisterChange(string regName) {
	safeListChangedParam(regName);
}

//this method is called by instrucitonManager to let this class
//know that it has changed the zad mode and it wants this class
//to let the gui know.
void Z_80LogicGate::notifyOfZadModeChange() {
	safeListChangedParam("ZAD_MODE");
}

//this method is used to change the hex display that
//is in the pop-up window.  It is called by the instruction
//manager when it is emulating the ZAD KBRD and SCAN
//functions
void Z_80LogicGate::setHexDisplay(string newValue) {
	hexDisplay = newValue;
	safeListChangedParam("HEX_DISP");
}

//this method is used to change the info string that
//is in the pop-up window.  It is called by the
//instruction manager when it is on instruction
//level stepping and (TODO) by the WaveformFSM when
//going through T-state level stepping
void Z_80LogicGate::setInfoString(string newValue) {
	infoString = newValue;
	safeListChangedParam("INFO_STRING");
}

//this is used by the emulated ZAD functions KBRD and SCAN
//inside of the instructionManager to determine what
//was key was the last pressed.
int Z_80LogicGate::getCurrentKeyboardHardCode() {
	return currentKeyboardHardCode;
}

//we don't want to get a real old key, the first thing
//KBRD will do is call this so that the key has to be
//pressed after the program halts within the KBRD
//routine
void Z_80LogicGate::resetCurrentKeyboardHardCode() {
	currentKeyboardHardCode = H_KEY_NONE;
	keyboardHardCodeSetTime = this->getSimTime();
}

//This allows the calling rutine to determine how old
//the key is.  Thus the SCAN method can ignore a key
//if it determines that it is too old
int Z_80LogicGate::getKeyboardHardCodeAge() {
	return (int)(this->getSimTime() - keyboardHardCodeSetTime);
}

//This function is used to test if the user remembered to
//power and ground the z80.  If this method returns false,
//then the z80 will refuse to simulate
bool Z_80LogicGate::isPowered() {
	return isLowActiveState(getInputState("GND"))
		&& isHighActiveState(getInputState("VCC"));
}


bool Z_80LogicGate::setParameter(string paramName, string value) {
	bool shouldReprocesses = false;
	if (paramName == "ZAD_MODE") {
		if (value == "ON" || value == "2") {
			waveformFSM.setZADMode(ZAD_MODE_ON, this);
		}
		else if (value == "OFF" || value == "1") {
			waveformFSM.setZADMode(ZAD_MODE_OFF, this);
		}
		else if (value == "SMART" || value == "0") {
			waveformFSM.setZADMode(ZAD_MODE_SMART, this);
		}
	}
	else if (paramName == "RUN_MODE") {
		if (value == "CONTINUOUS") {
			currentRunMode = CONTINUOUS;
		}
		else if (value == "T_STEP") {
			currentRunMode = T_STEP;
		}
		else if (value == "I_STEP") {
			currentRunMode = I_STEP;
		}
		waveformFSM.setRunMode(currentRunMode);
	}
	else if (paramName == "PAUSE_SIM") {
		//pause_sim can get set in the file
	}
	else if (paramName == "HEX_DISP") {
		hexDisplay = value;
	}
	else if (paramName == "INFO_STRING") {
		infoString = decodeParam(value);
	}
	else if (paramName == "H_KEY") {
		needToTimeStampKeyStroke = true;
		istringstream in(value);
		in >> hex >> currentKeyboardHardCode;
	}
	else {
		//we will assume that the param is a register value
		waveformFSM.setReg(paramName, value);
		shouldReprocesses = true;
	}
	return shouldReprocesses;
}

//overrides getParameter is super class.
string Z_80LogicGate::getParameter(string paramName) {
	string answer = "";
	if (paramName == "ZAD_MODE") {
		switch (waveformFSM.getZADMode()) {
		case ZAD_MODE_ON:
			answer = "ON";
			break;
		case ZAD_MODE_OFF:
			answer = "OFF";
			break;
		case ZAD_MODE_SMART:
			answer = "SMART";
			break;
		}
	}
	else if (paramName == "RUN_MODE") {
		switch (currentRunMode) {
		case CONTINUOUS:
			answer = "CONTINUOUS";
			break;
		case T_STEP:
			answer = "T_STEP";
			break;
		case I_STEP:
			answer = "I_STEP";
			break;
		}
	}
	else if (paramName == "HEX_DISP") {
		answer = hexDisplay;
	}
	else if (paramName == "INFO_STRING") {
		answer = encodeParam(infoString);
	}
	else if (paramName == "PAUSE_SIM") {
		//we only signal that we want to pause the simulation
		//when we do and not when we don't so we always return
		//true for this
		answer = "TRUE";
	}
	else if (paramName == "H_KEY") {
		answer = toHex(currentKeyboardHardCode);
	}
	else {
		//we will assume that the requested is
		//a paramiter requested is a name of a register
		answer = waveformFSM.getReg(paramName);

		//web page about cout
		//http://scs.ictp.it/manuals/pgi/pgC_lib/cou_4514.htm
	}
	return answer;
}

//listChangedParam is dangerouse to call because if it is not called
//from a that was called from gateProcess, an asertion will fail
//and the system will crash.  This method will make sure it is 
//safe to call it and then forward it the changed paramiter.
//If it is not safe, it will log it in a collection which
//will then be iterated next time gateProcess is called.
//This method is private because only methods in Z_80LogicGate
//should tecknically know the names of properties.
void Z_80LogicGate::safeListChangedParam(string paramName) {
	if (runningProcessGate) {
		listChangedParam(paramName);
	}
	else {
		safeListedParams.push_back(paramName);
	}
}


//this is called from gateProcess to go ahead and list all the
//paramiters which were listed by safeListParam which didn't get logged
void Z_80LogicGate::processSafeListedParams() {
	if (runningProcessGate) {
		for (auto I = safeListedParams.begin(); I != safeListedParams.end(); ++I) {
			listChangedParam(*I);
		}
		safeListedParams.clear();
	}
}
